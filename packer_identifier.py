import pefile
import os
import codecs
import binascii

"""
Objective: given a set of executables, check if any part of their hex string
           matches the signatures of some known packers.  Return string matches
           using Aho-Corasick algorithm.
"""

# dictionary to hold signature:name
sigDict = {}

# heuristic measure, no signature in packer signature file is shorter than this:
smallest_element = 4

# array for single hex values:
hex_array = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A',
             'B', 'C', 'D', 'E', 'F', '?']


class Node:
    def __init__(self):
        # empty list for pointers, initialize to 16 for hex + 1 for '?' wildcard
        self.path_node = [None] * 17
        
        # if True, node is the last node of a signature
        self.end_of_sig = False
        # if True, node is the last node in a Trie path 
        self.end_of_path = False


class Trie:
    def __init__(self):
        self.root = self.create_node()

    """ returns a new Node (NULL-initialized) """
    def create_node(self):
        return Node()

    """ private helper function that returns corresponding index for hex char """
    def _hexToIndex(self, hex_char):
        return hex_array.index(hex_char)

    """ inserts signatures into trie """
    def insert(self, signature):
        
        search = self.root

        for nibble in signature:
            index = self._hexToIndex(nibble)

            # if current nibble not present in trie path:
            if search.path_node[index] == None:
                search.path_node[index] = self.create_node()

            """ 
                if current node was end of path, set to
                false because you're adding to it (ex. th[e] -> th[e]re)
            """
            if search.end_of_path:
                search.end_of_path = False

            search = search.path_node[index]

        # mark final node as leaf:
        search.end_of_sig = True
        search.end_of_path = True


    """ search signature in the trie return possible signature matches, if present """
    def search(self, executable):
        
        result = []

        # checks each character of the signature: 
        for nibble in range(len(executable)): 
            index = 0
            search = self.root
            flag = True
            temp_string = ""

            while flag:

                # reached end of executable but not end of sig or path:
                if (index + nibble) == len(executable): 
                    flag = False
                    continue

                path_index = self._hexToIndex(executable[index + nibble])

                search = search.path_node[path_index]

                # nibble not present in trie:
                if search == None: 
                    flag = False
                    continue

                # end of signature:
                if search.end_of_sig: 
                    temp_string += executable[index + nibble]

                    if (len(temp_string) >= smallest_element):
                        # only append if it's a valid signature:
                        if temp_string and set(sigDict.keys()):
                            result.append(temp_string)

                    # end of path: 
                    if search.end_of_path: 
                        flag = False
                        continue

                    # not end of path: 
                    elif search.end_of_path: 
                        index += 1

                # not end of signature or path: 
                elif search.end_of_sig == False and search.end_of_path == False: 
                    # if path_node has a valid '?', append current and continue: 
                    if search.path_node[16]: 
                        temp_string += executable[index + nibble]
                        index += 1
                        search = search.path_node[16]

                    else:
                        temp_string += executable[index + nibble]
                        index += 1

        result = set(result)

        return result


def main():

    # path to directory with executable samples
    dir_path = ""

    # check if needs preprocessing:
    answer = input("Does the directory require preprocessing, or has it already been done? Enter 1 for 'yes, requires', 2 for 'no, already done': ")

    if (answer == '1'):
        dir_path = input("Enter path to executables directory: ")
        preprocessing(dir_path)

    elif (answer == '2'):
        dir_path = input("Enter path to executables directory: ")
        analysis(dir_path)

    else:
        print("Input not recognized. Try again.")


""" cleans the data and leaves only Windows executables """
def preprocessing(dir_path):

    os.chdir(dir_path)

    for file in os.listdir(dir_path):
        # check if it's a Windows executable, if not, remove from directory
        try:
            win_exe = pefile.PE(file)
        except pefile.PEFormatError as pErr:
            #delete the file
            os.remove(file)

    print("Preprocessing complete.")
    analysis(dir_path)


""" builds the dictionary from the Packer_Signatures file.  Format: {signature:name} """
def buildPackerDictionary():


    pkr_path = input("Enter full path of the packer signatures file: ")
    os.chdir(os.path.dirname(pkr_path))


    sig_sig = ""
    sig_name = ""
    flag_new_name = False
    flag_new_sig = False

    with codecs.open(pkr_path, 'r', 'utf-16') as pkr_file: # utf-16 because that's what Windows .txt files are encoded as, python by default uses utf-8
        for line in pkr_file:
            # search for name:
            if line.find("[") != -1:
                sig_name = line
                sig_name.format()
                flag_new_name = True

            # search for the signature:
            if line.find("signature = ") != -1:
                sig_sig = line[12:];
                sig_sig = sig_sig.strip()
                sig_sig = sig_sig.replace(" ", "")
                flag_new_sig = True

            if flag_new_name and flag_new_sig:
                # add key:value to sigDic:
                sigDict.update({sig_sig:sig_name})
                flag_new_name = False
                flag_new_sig = False

    return


""" 
    goes through the given directory, takes contents of each
    exe as hex as string and does substring search on it
"""
def analysis(dir_path):

    buildPackerDictionary()

    os.chdir(dir_path)

    # read the data of every exe in the directory:
    for file in os.listdir(dir_path):
        with open(file, 'rb') as win_exe:
            data_buffer = win_exe.read()
            # convert it into a hex string:
            file_hex_data = binascii.hexlify(data_buffer)
            file_hex_data = str(file_hex_data)[2:len(file_hex_data) - 1]
            # pass the string to the search:
            aho_corasick_search(file_hex_data.upper())

    return


""" 
    implements Aho-Corasick search through the trie given 
    the hex string of a file, returns matching signatures' name 
"""
def aho_corasick_search(file):

    # Trie object:
    trie = Trie()

    # construct the trie:
    for sigs in sigDict.keys():
        trie.insert(sigs)

    result = trie.search(file)

    if (result != None):
        # intersection of the substrings returned and those present in the signatures file:
        for element in result:
            if element in sigDict.keys():
                print(sigDict.get(element))

    else:
        print("No similarities.")

    print("Analysis complete.  These are the potential packers returned.")


main()


